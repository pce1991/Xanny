exit
'("THE" _)
(into [] '("THE" _))
(list? 
'())
(into vector '(1))
(into vec '(1))
(defn marker? [str pattern/feature] ;give as list, put into vector
  "accepts a string and pattern, returning true if the str matches the pattern.
Multiple patterns can be given, and can be as complex as needed: might require or patterns,
or guarded ones. " 
  (if (list? pattern/feature)
    (match (tokenize str) (into [] pattern/feature) true
                 :else false)
    (pattern/feature str)))
(defn marker? [str marker] ;give as list, put into vector
  "accepts a string and pattern, returning true if the str matches the pattern.
Multiple patterns can be given, and can be as complex as needed: might require or patterns,
or guarded ones. " 
  (if (list? marker)
    (match (tokenize str) (into [] marker) true
                 :else false)
    (marker str)))
(use 'clojure.core.match)
(defn marker? [str marker] ;give as list, put into vector
  "accepts a string and pattern, returning true if the str matches the pattern.
Multiple patterns can be given, and can be as complex as needed: might require or patterns,
or guarded ones. " 
  (if (list? marker)
    (match (tokenize str) (into [] marker) true
                 :else false)
    (marker str)))
(defn marker? [str marker] ;give as list, put into vector
  "accepts a string and pattern, returning true if the str matches the pattern.
Multiple patterns can be given, and can be as complex as needed: might require or patterns,
or guarded ones. " 
  (if (list? marker)
    (let [marker-vec (into [] marker)]
      (match (tokenize str) marker-vec true
                 :else false)
    (marker str)))
)
exit
(marker? "THE BOOK" ["THE" "BOOK"])
(marker? "THE BOOK" ("THE" "BOOK"))
(into [] '("THE" "BOOK"))
(list? '("TH" "kd"))
(marker? "    THE BOOK" indented?)
(marker? "THE BOOK" '("THE" "BOOK"))
(marker? "THE BOOK" '("THE" _))
(tokenize "the book")
(def a ["THE" _])
(def a (into [] '("THE" _)))
a
(use 'clojure.
core.match)
(use 'clojure.core.match
)
a
(match ["THE" "BOOK"] a)
(match ["THE" "BOOK"] a true)
(match ["THE" "BOOK"] [a] true)
(match ["THE" "BOOK"] a true :else false)
(match ["THE" "BOOK"] [a] true :else false)
exit
(def bible (map-bible "text-files/the-holy-bible/KJV-text-only.txt"))
(def pl "text-files/POETRY/paradise-lost.txt")
(def pl (map-text "text-files/POETRY/paradise-lost.txt"))
(def pl (map-text "text-files/POETRY/paradise-lost.txt" (fn [line] (match (tokenize line) ["BOOK" _])) empty? (fn [line] (not (empty? line)))))
(use 'clojure.core.match
)
(def pl (map-text "text-files/POETRY/paradise-lost.txt" (fn [line] (match (tokenize line) ["BOOK" _])) empty? (fn [line] (not (empty? line)))))
(match [1 2 3 4 5] [1 2])
(match [1 2 3 4 5] [1 2] true)
(match [1 2 3 4 5] [1 2] true :else false)
(match [1 2 3 4 5] [1 2 _ _ _] true :else false)
(def pl (map-text "text-files/POETRY/paradise-lost.txt" (fn [line] (if (uppercase? line)(match (tokenize line) ["BOOK" _]))) empty? (fn [line] (not (empty? line)))))
(def pl (map-text "text-files/POETRY/paradise-lost.txt" (fn [line] (if (uppercase? line)(match (tokenize line) ["BOOK" _] true :else false))) empty? (fn [line] (not (empty? line)))))
pl
(seg pl 1 1 1)
(seg pl 1 1 2)
(seg pl 2 1 2)
(seg pl 10 1 2)
(seg pl 9 1 2)
(seg pl 8 1 2)
(seg pl 6 1 2)
(seg pl 6 1 1)
(seg pl 5 1 1)
(def pl (map-text "text-files/POETRY/paradise-lost.txt" (fn [line] (if (uppercase? line)(match (tokenize line) ["BOOK" _] true ["BOOK" _ _] true :else false))) empty? (fn [line] (not (empty? line)))))
pl
(seg pl 10 1 1)
(prt pl 10)
(seg pl 10 1 0)
(seg pl 10 0 0)
(rand-seg pl 10)
(rand-seg pl)
(dotimes [i 10] (println (rand-seg pl)))
bible
(dotimes [i 10] (println (rand-seg bible)))
(dotimes [i 2] (println (rand-seg bible)) (println (rand-seg pl)))
(get "That to the highth of this great Argument" pl)
(get pl "That to the highth of this great Argument")
(re-matches #"hello" "hello, world")
(re-matches #"hello*" "hello, world")
(re-matches #"hello *" "hello, world")
(re-matches #"hello .*" "hello, world")
(re-matches #"hello.*" "hello, world")
(re-matches #"THE.* BOOK" "THE FIRST BOOK")
(re-matches #"THE.* SHIT" "THE FIRST BOOK")
(re-matches #"THE.* BOOK" "THE FIRST BOOK")
(def a "THE.* BOOK")
a
(re-matches #a "THE FIRST BOOK")
(def a #"THE.* BOOK")
a
(re-matches a "THE FIRST BOOK")
(string? a)
(type a)
(pattern? a)
(regex? a)
a
(= java.util.regex.Pattern (type a))
(Pattern? a)
(defn pattern? [pat]
  (= java.util.regex.Pattern pat))
(pattern? a)
a
exit
(map-poetry "text-files/POETRY/paradise-lost.txt" "BOOK.*" empty? not-empty?) 
(not-empty? '(1))
(map-poetry "text-files/POETRY/paradise-lost.txt" "BOOK.*" empty? not-empty) 
(map-poetry "text-files/POETRY/paradise-lost.txt" #"BOOK.*" empty? not-empty) 
a
(def a #"BOOK.*")
a
(re-matches a "BOOK I")
(re-matches a "BOOK I.")
(re-matches a "BOOK X.")
(pattern? a)
(marker? "BOOK I" #"BOOK.*")
(marker? "  BOOK I" #"BOOK.*")
(marker? "  BOOK I" #".*BOOK.*")
(map-poetry "text-files/POETRY/paradise-lost.txt" #".*BOOK.*" empty? not-empty) 
(map-poetry "text-files/POETRY/paradise-lost.txt" #"BOOK.*" empty? not-empty) 
      THE END OF THE FIRST BOOK.
(re-matches #".*BOOK.*" "      THE END OF THE FIRST BOOK.
")
(re-matches #".*BOOK.*" "      THE END OF THE FIRST BOOK.")
(map-poetry "text-files/POETRY/paradise-lost.txt" #"  BOOK.*" empty? not-empty) 
(def pl (map-poetry "text-files/POETRY/paradise-lost.txt" #"  BOOK.*" empty? not-empty) )
pl
(prt pl 1)
(map println (prt pl 1))
(prt pl 1)
(sec pl 1 1)
(map println (sec pl 1 1))
(doseq [i (sec pl 1 1)] (println i))
(marker? "Of Mans First Disobedience, and the Fruit" (fn [line] (and (not-empty line) (not (indented? line)))))
(and 1 2 3)
(and 1 nil 2)
exit
(def pl (map-poetry "text-files/POETRY/paradise-lost.txt" #"  BOOK.*" empty? not-empty) )
pl
(print-entry pl 1 1 1)
(print-entry pl 1 1 )
(print-entry pl 1)
(print-entry pl)
(def pl (map-poetry "text-files/POETRY/paradise-lost.txt" #"  BOOK.*" empty? not-empty) )
pl
(prt-count pl)
(prt pl 8)
(prt pl )
(prt pl 9)
(prt pl 10)
(sec pl 9 1 1)
(seg pl 9 1 1)
(seg pl 9 1 0)
(seg pl 9 0 0)
(seg pl 9 1 0)
(seg pl 9 1 1)
(seg pl 9 1 2)
(seg pl 9 1 3)
pl
(def pl (map-poetry "text-files/POETRY/paradise-lost.txt" #"  BOOK.*" empty? not-empty) )
(print-entry pl)
(prt pl 9)
(print-entry pl 9)
(def pr (map-poetry "text-files/POETRY/paradise-regained.txt" #"THE.* BOOK" indented? not-empty) )
pr
(def pr (map-poetry "text-files/POETRY/paradise-regained.txt" #"  THE.* BOOK" indented? not-empty) )
pr
(seg pr 1 1 1)
(seg pr 1 1 0)
(seg pr 1 0 0)
(seg pr 1 0 1)
(seg pr 1 0 2)
(seg pr 1 0 0)
(seg pr 1 1 0)
(seg pr 1 1 1)
exit
(def pr (map-poetry "text-files/POETRY/paradise-regained.txt" #"  THE.* BOOK" indented? not-empty) )
(sec pr 1 1)
(sec pr 1 0)
(def pl (map-poetry "text-files/POETRY/paradise-lost.txt" #"  BOOK.*" empty? not-empty) )
(sec pl 1 0)
(sec pl 1 1)
(print-entry pl 1 1)
(print-entry pr 1 1)
(print-entry pr 1 0)
(print-entry pl)
(prt pl 1)
(sec pl 0)
(sec pl 1 0)
(sec-count pl 1)
(sec pl 1 1)
(sec-count pr 1)
exit
(def pl (map-poetry "text-files/POETRY/paradise-lost.txt" #"  BOOK.*" empty? not-empty) )
(sec pl 1 1)
(sec-count pr 1)
exit
(def pl (map-poetry "text-files/POETRY/paradise-lost.txt" #"  BOOK.*" empty? not-empty) )
(sec-count pr 1)
(sec-count pr 2)
(sec-count pl 2)
(sec-count pl 1)
exit
(def pr (map-poetry "text-files/POETRY/paradise-regained.txt" #"  THE.* BOOK" indented? not-empty) )
pr
(sec pr 1 1)
(sec pr 1 0)
(prt pr 1)
(seg pr 1 1 0)
(seg pr 1 0 0)
(seg pr 0 0 0)
(seg pr 1 0 0)
pl
(def pl (map-poetry "text-files/POETRY/paradise-lost.txt" #"  BOOK.*" empty? not-empty) )
(sec pl 1 0)
(sec pl 1 1)
(prt pl 1)
(print-entry pr 1 1)
(print-entry pr 1 0)
(print-entry pr 1 1)
exit
(def pl (map-poetry "text-files/POETRY/paradise-lost.txt" #"  BOOK.*" empty? not-empty) )
(print-random pl)
(dotimes [i 10] (print-random pl))
(dotimes [i 10] (print-random pl 1))
(def pl (map-poetry "text-files/POETRY/paradise-lost.txt" #"  BOOK.*" empty? not-empty) )
pl
(dotimes [i 10] (print-random pl))
(def pl (map-poetry "text-files/POETRY/paradise-lost.txt" #"  BOOK.*" empty? (fn [line] (and (not-emtpy line) (not (uppercase? line))) )))
(def pl (map-poetry "text-files/POETRY/paradise-lost.txt" #"  BOOK.*" empty? (fn [line] (and (not-empty line) (not (uppercase? line))) )))
pl
(sec pl 1 1)
(prt pl 1)
(print-entry pl 1)
(print-entry pl 2)
(print-entry pl)
(sec pl 1)
(sec pl 1 0) 
(sec pl 1 1) 
(def pl (map-poetry "text-files/POETRY/paradise-lost.txt" #"  BOOK.*" empty? (fn [line] (and (not-empty line) (not (uppercase? line))) )))
(third '(1 2 3 4))
(fourth '(1 2 3 4))
(second '(1 2 3 4))
(nth 1 '(1 2 3 4))
(nth '(1 2 3 4) 3)
exit
(def pl (map-poetry "text-files/POETRY/paradise-lost.txt" #"  BOOK.*" empty? (fn [line] (and (not-empty line) (not (uppercase? line))) )))
pl
(cmp-index '(1 1 1) '(2 3 4)
)
(cmp-index '(3 1 1) '(2 3 4)
)
(cmp-index '(3 1 1) '(3 3 4)
)
(cmp-index '(3 1 1) '(3 3 1))
(cmp-index '(3 1 1) '(3 0 1))
(sorted-map-by cmp-index pl)
c
(sorted-map-by cmp-index pl)
2
pl
(get '(10 17 7) pl)
(seg pl 10 17 7)
(get pl '(10 17 7))
pl
(compare '(1 2 3) '(1 1 1))
(sorted-map-by > pl)
3
'{:a 'b)
'{:a 'b
}
{}
[]
][
]
[]
][
]
][][
]
(map-bible "text-files/the-holy-bible/KJV-text-only.txt")
(def b (map-bible "text-files/the-holy-bible/KJV-text-only.txt"))
(sorted-map-by cmp-index b)
(def f "text-files/PROSE/JOYCE/Finnegans-Wake.txt")
(def f (trim-front f nil))
(def ff (lonely-lines f))
(subvec (into [] ff) 40 42
)
(subvec (into [] ff) 40 43)
(def f "text-files/PROSE/JOYCE/Finnegans-Wake.txt")
quit
exit
quit
(re-matches nil "hi")
quit
(all-vocab)
(map concat (all-vocab))
(map concat '((1 2) (3 4)))
(refresh)
(vocab-quiz (all-vocab))
(read-line
)
quit
(vocab-quiz (all-vocab))
quit
(vocab-quiz (all-vocab))
(all-vocab)
(def v (vocab-quiz (all-vocab)))
v
(vocab-quiz v)
(quit)
(load-text "Shakespeare" "Plays"
)
(def s ((texts "Shakespeare") "Plays"))
(first s)
(fetch s {0 1})
(fetch s {0 2})
(fetch s {0 7})
(fetch s {1 0 2 0 3 0 4 0})
(load-text "Walt Whitman")
(def w (texts "Walt Whitman"))
(fetch w {0 1 1 1})
quit
(vocab-quiz (all-vocab))
(quit)
(def b (letter-bi-gram names))
(generate-name b)
(refresh)
(def b (letter-bi-gram names))
(generate-name b)
(refresh)
(def b (letter-bi-gram names))
(generate-name b)
(refresh)
(def b (letter-bi-gram names))
(vec (pick-letter (:START b)))
[(pick-letter (:START b)))]
[(pick-letter (:START b))]
(refresh)
(def b (letter-bi-gram names))
(generate-name b)
(def b (letter-bi-gram names))
(generate-name b)
quit
(all-vocab)
(sort (all-vocab)
)
(dict "gereo")
(dict "gero")
(dict "sub")
(dict "porta")
(dict "ad")
(dict "duco")
(dict "ago")
(dict "vita"(
)
(dict "bona")
(dict "virtus")
(dict "audeo")
(dict "ratioo")
(dict "ratio")
(dict "copio")
(dict "copia")
(dict "magno")
(dict "magna")
(dict "magnus")
(dict "numquam")
(dict "debeo")
(dict "tum")
(dict "ex")
(dict "duco")
(dict "in")
(dict "nos")
(dict "doceo")
(refresh)
(load-text "Quran" "Yusuf Ali")
(def q ((texts "Quran") "Yusuf Ali"))
(fetch q {3 99})
(fetch q {3 1})
(fetch q {3 2})
(first (fetch q {3 2}))
(second (fetch q {3 2}))
(refresh)
(load-text "Quran" "Yusuf Ali")
(def q ((texts "Quran") "Yusuf Ali"))
q
(refresh)
(load-text "Quran" "Yusuf Ali")
(def q ((texts "Quran") "Yusuf Ali"))
(fetch q {3 2})
(fetch q {3 1})
(refresh)
(load-text "Quran" "Yusuf Ali")
(def q ((texts "Quran") "Yusuf Ali"))
(fetch q {3 1})
(refresh)
(load-text "Quran" "Yusuf Ali")
(def q ((texts "Quran") "Yusuf Ali"))
(sublist q 0 10
)
q
(first q)
(second q)
(sublist q 0 3)
(sublist q 0 4)
quit
(prepare-to-clean "text-files/quran.txt" nil nil)
(prepare-to-clean "text-files/quran.txt" [] [])
(prepare-to-clean "text-files/quran.txt" [])
(prepare-to-clean "text-files/quran.txt" [#"----.*" true] [#".*(?i)End of\s?(the)? Project Gutenberg.*" true])
(def q (prepare-to-clean "text-files/quran.txt" [#"----.*" true] [#".*(?i)End of\s?(the)? Project Gutenberg.*" true]))
(cut-chunk q #"P:.*|S:.*" #"")
(def qq (cut-chunk q #"P:.*|S:.*" #""))
(smush-chunk qq :smush-start {#" Chapter .*|\s{4,}In the name of Allah,.*" #"\ {4,}[A-Z(),\ -]+"
))))
(smush-chunk qq :smush-start {#" Chapter .*|\s{4,}In the name of Allah,.*" #"\ {4,}[A-Z(),\ -]+"
)                                                          #"Y:.*"  #""}
(smush-chunk qq {#" Chapter .*|\s{4,}In the name of Allah,.*" #"\ {4,}[A-Z(),\ -]+" #"Y:.*"  #""} true false)
(def qqq (smush-chunk qq {#" Chapter .*|\s{4,}In the name of Allah,.*" #"\ {4,}[A-Z(),\ -]+" #"Y:.*"  #""} true false))
(first qqq)
(sublist qqq 0 10)
(sublist qqq 0 11)
(count qqq)
(sublist qqq 19600)
(def qqqq (remove-lines qqq [#"----.*" #"[0-9]{3}\.[0-9]{3}" #" Total Verses.*" ]))
(sublist qqqq 19600)
(count qqqq)
(sublist qqqq 13160)
(def qqqq (remove-lines qq [#"----.*" #"[0-9]{3}\.[0-9]{3}" #" Total Verses.*" ]))
(count qqqq)
(count qq)
(sublist qqqq 23060)
(smush-chunk qqqq :smush-start {#" Chapter .*|\s{4,}In the name of Allah,.*" #"\ {4,}[A-Z(),\ -]+"
(def qqq (smush-chunk qqqq {#" Chapter .*|\s{4,}In the name of Allah,.*" #"\ {4,}[A-Z(),\ -]+" #"Y:.*"  #""} true false))
(count qqq)
(sublist qqq 13160)
(map-text "Quran" "Yusuf Ali")
(load-text "Quran" "Yusuf Ali")
(def q ((texts "Quran) "Yusuf Ali"))
)0"
)))
(def q ((texts "Quran") "Yusuf Ali"))
(count q)
(last q)
(refresh)
(load-text "Walt Whitman")
(def w (texts "Walt Whitman"))
(count w)
(fetch w {0 1 1 1})
(load-text "Milton" "Paradise Lost")
(load-text "John Milton" "Paradise Lost")
(def pl ((texts "John Milton") "Paradise Lost"))
(last pl)
(first pl)
pl
(refresh)
(load-text "John Milton" "Paradise Lost")
(def pl ((texts "John Milton") "Paradise Lost"))
pl
(defn y [x z [a b]] (println x z [a b]))
(y 1 2 [3 4])
w
(load-text "Walt Whitman")
(def w (texts "Walt Whitman"))
(fetch w {0 1 1 7})
y
(defn y [[a b c d e f g h i j k l m n o p q r s t u v w x y z] (println [a x]))
(defn y [[a b c d e f g h i j k l m n o p q r s t u v w x y z]] (println [a x]))
(defn z [a b c d e f g h i j k l m n o p q r s t u v w x y z] (println 1))
quit
(use 'xanny.text-processing)
quit
(use 'xanny.text_processing)
(refresh)
(re-matches-some [#"a" #"b"] "c")
quit
